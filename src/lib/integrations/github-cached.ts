import { Octokit } from '@octokit/rest';
import { PrismaClient } from '@/generated/prisma';
import { withRetry, RetryPresets } from '@/lib/retry-utils';
import { RedisCache, CacheKeyGenerator, TTLManager } from '@/lib/redis';

const prisma = new PrismaClient();

// In-memory cache for GitHub API responses
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class GitHubCache {
  private cache = new Map<string, CacheEntry<any>>();
  private readonly defaultTTL = 5 * 60 * 1000; // 5 minutes

  /**
   * Stores data in the cache with a specified key and time-to-live.
   */
  set<T>(key: string, data: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  /**
   * Deletes a key from the cache.
   */
  delete(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Clears the cache.
   */
  clear(): void {
    this.cache.clear();
  }

  // Generate cache key for GitHub API calls
  /**
   * Generates a key based on the operation and sorted parameters.
   */
  generateKey(operation: string, params: Record<string, any>): string {
    const sortedParams = Object.keys(params)
      .sort()
      .map(key => `${key}:${params[key]}`)
      .join('|');
    return `github:${operation}:${sortedParams}`;
  }

  // Get cache statistics
  /**
   * Gets statistics about cache entries, including total, valid, and expired entries.
   */
  getStats() {
    const now = Date.now();
    let validEntries = 0;
    let expiredEntries = 0;

    for (const [key, entry] of this.cache) {
      if (now - entry.timestamp > entry.ttl) {
        expiredEntries++;
      } else {
        validEntries++;
      }
    }

    return {
      totalEntries: this.cache.size,
      validEntries,
      expiredEntries,
    };
  }
}

// Global cache instance
const githubCache = new GitHubCache();

// Cache configuration for different API operations
const CACHE_CONFIG = {
  // Repository data - cache for 30 minutes
  repos: {
    list: 30 * 60 * 1000,
    get: 30 * 60 * 1000,
  },
  // Commits - cache for 5 minutes
  commits: {
    list: 5 * 60 * 1000,
  },
  // Pull requests - cache for 10 minutes
  pulls: {
    list: 10 * 60 * 1000,
    get: 10 * 60 * 1000,
  },
  // Issues - cache for 10 minutes
  issues: {
    list: 10 * 60 * 1000,
    get: 10 * 60 * 1000,
  },
  // User data - cache for 1 hour
  user: {
    get: 60 * 60 * 1000,
  },
  // Rate limit - cache for 1 minute
  rateLimit: 60 * 1000,
};

export interface GitHubActivity {
  source: 'github';
  title: string;
  description?: string;
  timestamp: Date;
  externalId: string;
  metadata?: any;
}

export interface GitHubEvent {
  id: string;
  type: string | null;
  actor: {
    login: string;
    display_login?: string;
    avatar_url: string;
  };
  repo: {
    name: string;
    id: number;
  };
  payload?: any;
  created_at: string | null;
  public: boolean;
}

/**
 * Cached GitHub API client wrapper
 */
class CachedGitHubClient {
  private octokit: Octokit;
  private userId: string;

  constructor(accessToken: string, userId: string) {
    this.octokit = new Octokit({
      auth: accessToken,
      userAgent: 'UnifiedHQ/1.0.0',
    });
    this.userId = userId;
  }

  /**
   * Get cached or fetch fresh data from GitHub API with Redis caching.
   *
   * This function implements a multi-layer caching strategy:
   * 1. First checks Redis cache for the data
   * 2. Falls back to in-memory cache if Redis is unavailable
   * 3. Fetches fresh data from GitHub API if not cached
   * 4. Stores the result in both Redis and memory cache
   *
   * @param operation - The operation name to identify the request.
   * @param params - The parameters to be used for the request.
   * @param ttl - The time-to-live for the cached data in milliseconds.
   * @param fetcher - A function that fetches fresh data from the API.
   * @returns The fetched or cached data.
   * @throws Any error encountered during the fetching process, including rate limit errors.
   */
  private async cachedRequest<T>(
    operation: string,
    params: Record<string, any>,
    ttl: number,
    fetcher: () => Promise<T>
  ): Promise<T> {
    // Generate cache keys for both Redis and in-memory cache
    const redisCacheKey = CacheKeyGenerator.github(
      this.userId,
      operation,
      JSON.stringify(params)
    );
    const memoryCacheKey = githubCache.generateKey(
      `${this.userId}:${operation}`,
      params
    );

    // Try Redis cache first
    const redisData = await RedisCache.get<T>(redisCacheKey);
    if (redisData) {
      console.log(`[GitHub Cache] Redis cache hit for ${operation}`);
      // Also store in memory cache for faster subsequent access
      githubCache.set(memoryCacheKey, redisData, ttl);
      return redisData;
    }

    // Try in-memory cache as fallback
    const memoryData = githubCache.get<T>(memoryCacheKey);
    if (memoryData) {
      console.log(`[GitHub Cache] Memory cache hit for ${operation}`);
      // Store in Redis for persistence
      await RedisCache.set(redisCacheKey, memoryData, Math.floor(ttl / 1000));
      return memoryData;
    }

    console.log(
      `[GitHub Cache] Cache miss for ${operation}, fetching from API`
    );

    try {
      const result = await withRetry(
        async () => {
          const data = await fetcher();

          // Store in both caches
          githubCache.set(memoryCacheKey, data, ttl);
          await RedisCache.set(redisCacheKey, data, Math.floor(ttl / 1000));

          return data;
        },
        {
          ...RetryPresets.github,
          onRetry: (error, attempt, delay) => {
            console.warn(
              `[GitHub Cache] API call failed for ${operation} (attempt ${attempt}), retrying in ${delay}ms:`,
              error.message
            );
          },
          onMaxRetriesExceeded: (error, attempts) => {
            console.error(
              `[GitHub Cache] API call failed for ${operation} after ${attempts} attempts:`,
              error.message
            );
          },
        }
      );
      return result.data;
    } catch (error: any) {
      // If it's a rate limit error after all retries, try to get cached data even if expired
      if (error.status === 403 && error.message?.includes('rate limit')) {
        console.warn(
          `[GitHub Cache] Rate limit hit for ${operation} after retries, trying expired cache`
        );

        // Try Redis first for expired data
        const expiredRedisData = await RedisCache.get<T>(redisCacheKey);
        if (expiredRedisData) {
          return expiredRedisData;
        }

        // Fall back to memory cache
        const expiredMemoryData = githubCache.get<T>(memoryCacheKey);
        if (expiredMemoryData) {
          return expiredMemoryData;
        }
      }
      throw error;
    }
  }

  /**
   * Retrieves the user's repositories with caching.
   */
  async getRepositories(): Promise<any[]> {
    return this.cachedRequest(
      'repos.list',
      { userId: this.userId },
      CACHE_CONFIG.repos.list,
      async () => {
        const response = await this.octokit.rest.repos.listForAuthenticatedUser(
          {
            per_page: 100,
            sort: 'updated',
          }
        );
        return response.data;
      }
    );
  }

  /**
   * Get repository commits with caching
   */
  async getCommits(owner: string, repo: string, perPage = 10): Promise<any[]> {
    return this.cachedRequest(
      'commits.list',
      { owner, repo, perPage },
      CACHE_CONFIG.commits.list,
      async () => {
        const response = await this.octokit.rest.repos.listCommits({
          owner,
          repo,
          per_page: perPage,
        });
        return response.data;
      }
    );
  }

  /**
   * Fetches pull requests for a repository with caching.
   */
  async getPullRequests(
    owner: string,
    repo: string,
    perPage = 10
  ): Promise<any[]> {
    return this.cachedRequest(
      'pulls.list',
      { owner, repo, perPage },
      CACHE_CONFIG.pulls.list,
      async () => {
        const response = await this.octokit.rest.pulls.list({
          owner,
          repo,
          state: 'all',
          per_page: perPage,
          sort: 'updated',
        });
        return response.data;
      }
    );
  }

  /**
   * Fetches issues from a repository with caching support.
   */
  async getIssues(owner: string, repo: string, perPage = 10): Promise<any[]> {
    return this.cachedRequest(
      'issues.list',
      { owner, repo, perPage },
      CACHE_CONFIG.issues.list,
      async () => {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
          repo,
          state: 'all',
          per_page: perPage,
          sort: 'updated',
        });
        return response.data;
      }
    );
  }

  /**
   * Get user information with caching
   */
  async getUser(): Promise<any> {
    return this.cachedRequest(
      'user.get',
      { userId: this.userId },
      CACHE_CONFIG.user.get,
      async () => {
        const response = await this.octokit.rest.users.getAuthenticated();
        return response.data;
      }
    );
  }

  /**
   * Retrieves rate limit information with caching.
   */
  async getRateLimit(): Promise<any> {
    return this.cachedRequest(
      'rateLimit.get',
      { userId: this.userId },
      CACHE_CONFIG.rateLimit,
      async () => {
        const response = await this.octokit.rest.rateLimit.get();
        return response.data;
      }
    );
  }
}

/**
 * Database-based cache for GitHub activities
 */
class DatabaseCache {
  /**
   * Store GitHub activities in database with caching metadata
   */
  static async storeActivities(
    userId: string,
    activities: GitHubActivity[],
    cacheKey: string
  ): Promise<void> {
    const cacheEntry = {
      userId,
      cacheKey,
      data: activities,
      timestamp: new Date(),
      ttl: 5 * 60 * 1000, // 5 minutes
    };

    // Store in database cache table
    await prisma.gitHubCache.upsert({
      where: {
        userId_cacheKey: {
          userId,
          cacheKey,
        },
      },
      update: {
        data: cacheEntry.data as any,
        timestamp: cacheEntry.timestamp,
        ttl: cacheEntry.ttl,
      },
      create: {
        userId,
        cacheKey,
        data: cacheEntry.data as any,
        timestamp: cacheEntry.timestamp,
        ttl: cacheEntry.ttl,
      },
    });
  }

  /**
   * Retrieves cached activities from the database for a specific user.
   *
   * This function checks if a cache entry exists for the given userId and cacheKey.
   * If found, it evaluates the age of the cache entry against its time-to-live (ttl).
   * If the cache is expired, it deletes the entry and returns null. Otherwise, it returns the cached data as an array of GitHubActivity.
   *
   * @param userId - The ID of the user whose activities are being retrieved.
   * @param cacheKey - The key associated with the cached activities.
   */
  static async getCachedActivities(
    userId: string,
    cacheKey: string
  ): Promise<GitHubActivity[] | null> {
    const cacheEntry = await prisma.gitHubCache.findUnique({
      where: {
        userId_cacheKey: {
          userId,
          cacheKey,
        },
      },
    });

    if (!cacheEntry) return null;

    const now = new Date();
    const cacheAge = now.getTime() - cacheEntry.timestamp.getTime();

    if (cacheAge > cacheEntry.ttl) {
      // Cache expired, delete it
      await prisma.gitHubCache.delete({
        where: {
          userId_cacheKey: {
            userId,
            cacheKey,
          },
        },
      });
      return null;
    }

    return cacheEntry.data as unknown as GitHubActivity[];
  }

  /**
   * Clear expired cache entries older than 24 hours.
   */
  static async clearExpiredCache(): Promise<void> {
    const now = new Date();
    await prisma.gitHubCache.deleteMany({
      where: {
        timestamp: {
          lt: new Date(now.getTime() - 24 * 60 * 60 * 1000), // Delete entries older than 24 hours
        },
      },
    });
  }

  /**
   * Clear all cache for a user.
   */
  static async clearUserCache(userId: string): Promise<void> {
    await prisma.gitHubCache.deleteMany({
      where: { userId },
    });
  }
}

/**
 * Fetches GitHub activity for a specified user with comprehensive caching.
 *
 * This function retrieves the user's GitHub connection and selected repositories, then attempts to fetch cached activities from the database. If no cache is found, it fetches the activities from the GitHub API, processes commits, pull requests, and issues, and stores the results in the cache. It handles rate limits and errors gracefully, ensuring that the user is informed of any issues with their GitHub token.
 *
 * @param userId - The ID of the user whose GitHub activity is to be fetched.
 * @returns A promise that resolves to an array of GitHubActivity objects.
 * @throws Error If the GitHub connection is not found, the token is expired or invalid, or if fetching activities fails.
 */
export async function fetchGithubActivity(
  userId: string
): Promise<GitHubActivity[]> {
  console.log(`[GitHub Sync] Starting cached sync for user: ${userId}`);

  const connection = await prisma.connection.findFirst({
    where: {
      userId,
      type: 'github',
    },
  });

  if (!connection) {
    console.log(`[GitHub Sync] No GitHub connection found for user: ${userId}`);
    throw new Error('GitHub not connected');
  }

  // Get selected repositories
  const selectedRepos = await prisma.selectedRepository.findMany({
    where: {
      userId,
    },
  });

  if (selectedRepos.length === 0) {
    return [];
  }

  // Generate cache key for this user's activity
  const cacheKey = `activities:${userId}:${selectedRepos
    .map(r => r.repoId)
    .sort()
    .join(',')}`;

  // Try to get from database cache first
  const cachedActivities = await DatabaseCache.getCachedActivities(
    userId,
    cacheKey
  );
  if (cachedActivities) {
    console.log(`[GitHub Cache] Database cache hit for user ${userId}`);
    return cachedActivities;
  }

  console.log(
    `[GitHub Cache] Database cache miss for user ${userId}, fetching from API`
  );

  const client = new CachedGitHubClient(connection.accessToken, userId);
  const allActivities: GitHubActivity[] = [];

  console.log(`[GitHub Cache] Selected repositories: ${selectedRepos.length}`);
  selectedRepos.forEach(repo => {
    console.log(`  - ${repo.repoName}`);
  });

  try {
    // Check rate limit first
    const rateLimit = await client.getRateLimit();
    console.log(
      `[GitHub Cache] Rate limit: ${rateLimit.rate.remaining}/${rateLimit.rate.limit}`
    );

    if (rateLimit.rate.remaining < 10) {
      console.warn(
        `[GitHub Cache] Low rate limit remaining: ${rateLimit.rate.remaining}`
      );
    }

    // Fetch activity from each selected repository
    for (const repo of selectedRepos) {
      const [owner, repoName] = repo.repoName.split('/');
      console.log(
        `[GitHub Cache] Fetching activity for ${owner}/${repoName}...`
      );

      try {
        // Fetch recent commits, PRs, and issues with caching
        const [commits, pullRequests, issues] = await Promise.all([
          client.getCommits(owner, repoName, 10),
          client.getPullRequests(owner, repoName, 10),
          client.getIssues(owner, repoName, 10),
        ]);

        console.log(
          `[GitHub Cache] Fetched for ${owner}/${repoName}: ${commits.length} commits, ${pullRequests.length} PRs, ${issues.length} issues`
        );

        // Convert commits to activities
        commits.forEach(commit => {
          allActivities.push({
            source: 'github',
            title: `Committed to ${repo.repoName}`,
            description: commit.commit.message.split('\n')[0],
            timestamp: new Date(
              commit.commit.author?.date ||
                commit.commit.committer?.date ||
                new Date()
            ),
            externalId: commit.sha,
            metadata: {
              eventType: 'commit',
              repo: { id: repo.repoId, name: repo.repoName },
              actor: commit.author || commit.committer,
              payload: {
                commit: {
                  sha: commit.sha,
                  message: commit.commit.message,
                  url: commit.html_url,
                },
              },
            },
          });
        });

        // Convert pull requests to activities
        pullRequests.forEach(pr => {
          allActivities.push({
            source: 'github',
            title: `${pr.state === 'open' ? 'Opened' : pr.state === 'closed' ? 'Closed' : 'Updated'} PR #${pr.number} in ${repo.repoName}`,
            description: pr.title,
            timestamp: new Date(pr.updated_at),
            externalId: `pr-${pr.id}`,
            metadata: {
              eventType: 'pull_request',
              repo: { id: repo.repoId, name: repo.repoName },
              actor: pr.user,
              payload: {
                pull_request: {
                  number: pr.number,
                  title: pr.title,
                  state: pr.state,
                  url: pr.html_url,
                },
              },
            },
          });
        });

        // Convert issues to activities (filter out pull requests)
        issues
          .filter(issue => !issue.pull_request)
          .forEach(issue => {
            allActivities.push({
              source: 'github',
              title: `${issue.state === 'open' ? 'Opened' : issue.state === 'closed' ? 'Closed' : 'Updated'} issue #${issue.number} in ${repo.repoName}`,
              description: issue.title,
              timestamp: new Date(issue.updated_at),
              externalId: `issue-${issue.id}`,
              metadata: {
                eventType: 'issue',
                repo: { id: repo.repoId, name: repo.repoName },
                actor: issue.user,
                payload: {
                  issue: {
                    number: issue.number,
                    title: issue.title,
                    state: issue.state,
                    url: issue.html_url,
                  },
                },
              },
            });
          });
      } catch (repoError: any) {
        console.warn(
          `Failed to fetch activity for ${repo.repoName}:`,
          repoError.message
        );
      }
    }

    // Sort by timestamp (most recent first) and limit to 50 activities
    const sortedActivities = allActivities
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, 50);

    // Store in database cache
    await DatabaseCache.storeActivities(userId, sortedActivities, cacheKey);

    console.log(
      `[GitHub Sync] Total activities fetched and cached: ${sortedActivities.length}`
    );

    if (sortedActivities.length > 0) {
      console.log('[GitHub Sync] Sample activity:', {
        title: sortedActivities[0].title,
        timestamp: sortedActivities[0].timestamp,
        metadata: sortedActivities[0].metadata,
      });
    }

    return sortedActivities;
  } catch (error: any) {
    if (error.status === 401) {
      throw new Error(
        'GitHub token expired or invalid. Please reconnect your GitHub account.'
      );
    }
    throw new Error(`Failed to fetch GitHub activity: ${error.message}`);
  }
}

/**
 * Map GitHub event to our unified activity format.
 *
 * This function processes various types of GitHub events and constructs a unified activity object.
 * It extracts relevant information such as the actor, repository name, and event-specific details
 * to create a title and description for the activity. The function handles multiple event types,
 * including PushEvent, PullRequestEvent, IssuesEvent, and others, ensuring that the output is
 * consistent and informative.
 *
 * @param event - The GitHub event to be mapped, containing details about the actor, repository,
 *                and event payload.
 * @returns A GitHubActivity object representing the mapped activity.
 */
function mapGitHubEventToActivity(event: GitHubEvent): GitHubActivity {
  const actor = event.actor.display_login || event.actor.login;
  const repoName = event.repo.name;

  let title = '';
  let description = '';

  switch (event.type || 'UnknownEvent') {
    case 'PushEvent':
      const commits = event.payload?.commits || [];
      const commitCount = commits.length;
      title = `Pushed ${commitCount} commit${commitCount === 1 ? '' : 's'} to ${repoName}`;
      description = commits.length > 0 ? commits[0].message : undefined;
      break;

    case 'PullRequestEvent':
      const pr = event.payload?.pull_request;
      const action = event.payload?.action;
      title = `${action === 'opened' ? 'Opened' : action === 'closed' ? 'Closed' : action} PR #${pr?.number} in ${repoName}`;
      description = pr?.title;
      break;

    case 'IssuesEvent':
      const issue = event.payload?.issue;
      const issueAction = event.payload?.action;
      title = `${issueAction === 'opened' ? 'Opened' : issueAction === 'closed' ? 'Closed' : issueAction} issue #${issue?.number} in ${repoName}`;
      description = issue?.title;
      break;

    case 'IssueCommentEvent':
      const comment = event.payload?.comment;
      const issueForComment = event.payload?.issue;
      title = `Commented on issue #${issueForComment?.number} in ${repoName}`;
      description =
        comment?.body?.substring(0, 100) +
        (comment?.body?.length > 100 ? '...' : '');
      break;

    case 'PullRequestReviewEvent':
      const review = event.payload?.review;
      const prForReview = event.payload?.pull_request;
      title = `Reviewed PR #${prForReview?.number} in ${repoName}`;
      description =
        review?.body?.substring(0, 100) +
        (review?.body?.length > 100 ? '...' : '');
      break;

    case 'CreateEvent':
      const ref = event.payload?.ref;
      const refType = event.payload?.ref_type;
      title = `Created ${refType} ${ref ? `'${ref}'` : ''} in ${repoName}`;
      break;

    case 'DeleteEvent':
      const deletedRef = event.payload?.ref;
      const deletedRefType = event.payload?.ref_type;
      title = `Deleted ${deletedRefType} ${deletedRef ? `'${deletedRef}'` : ''} in ${repoName}`;
      break;

    case 'ForkEvent':
      const forkedRepo = event.payload?.forkee;
      title = `Forked ${repoName}`;
      description = forkedRepo?.full_name;
      break;

    case 'WatchEvent':
      title = `Starred ${repoName}`;
      break;

    case 'ReleaseEvent':
      const release = event.payload?.release;
      title = `Released ${release?.tag_name} in ${repoName}`;
      description = release?.name;
      break;

    default:
      title = `${event.type} in ${repoName}`;
      break;
  }

  return {
    source: 'github',
    title,
    description,
    timestamp: new Date(event.created_at || new Date()),
    externalId: event.id,
    metadata: {
      eventType: event.type,
      actor: event.actor,
      repo: event.repo,
      payload: event.payload,
    },
  };
}

/**
 * Save GitHub activities to the database, avoiding duplicates.
 */
export async function saveGithubActivities(
  userId: string,
  activities: GitHubActivity[]
): Promise<void> {
  for (const activity of activities) {
    await prisma.activity.upsert({
      where: {
        userId_source_externalId: {
          userId,
          source: activity.source,
          externalId: activity.externalId,
        },
      },
      update: {
        title: activity.title,
        description: activity.description,
        timestamp: activity.timestamp,
        metadata: activity.metadata,
      },
      create: {
        userId,
        source: activity.source,
        title: activity.title,
        description: activity.description,
        timestamp: activity.timestamp,
        externalId: activity.externalId,
        metadata: activity.metadata,
      },
    });
  }
}

/**
 * Get stored GitHub activities for a user
 * Only returns activities from selected repositories
 */
export async function getGithubActivities(
  userId: string,
  limit = 10
): Promise<GitHubActivity[]> {
  // Get selected repositories
  const selectedRepos = await prisma.selectedRepository.findMany({
    where: {
      userId,
    },
  });

  if (selectedRepos.length === 0) {
    return [];
  }

  const selectedRepoIds = new Set(selectedRepos.map(repo => repo.repoId));

  const activities = await prisma.activity.findMany({
    where: {
      userId,
      source: 'github',
    },
    orderBy: {
      timestamp: 'desc',
    },
    take: limit * 2, // Get more activities to filter
  });

  // Filter activities to only include those from selected repositories
  const filteredActivities = activities.filter(activity => {
    const metadata = activity.metadata as any;
    const repoId = metadata?.repo?.id;
    return repoId && selectedRepoIds.has(repoId);
  });

  return filteredActivities.slice(0, limit).map(activity => ({
    source: activity.source as 'github',
    title: activity.title,
    description: activity.description || undefined,
    timestamp: activity.timestamp,
    externalId: activity.externalId || '',
    metadata: activity.metadata,
  }));
}

/**
 * Checks if the user has a GitHub connection.
 */
export async function isGithubConnected(userId: string): Promise<boolean> {
  const connection = await prisma.connection.findFirst({
    where: {
      userId,
      type: 'github',
    },
  });
  return Boolean(connection);
}

/**
 * Retrieves the count of selected repositories for a given user.
 */
export async function getSelectedRepositoryCount(
  userId: string
): Promise<number> {
  const count = await prisma.selectedRepository.count({
    where: {
      userId,
    },
  });
  return count;
}

/**
 * Disconnect GitHub integration for a user.
 *
 * This function deletes all GitHub-related connections, selected repositories, and activities associated with the specified userId.
 * It also clears the user's cache to ensure that no stale data remains. The function utilizes the prisma client to perform
 * the deletions and interacts with the DatabaseCache to manage the user's cache.
 *
 * @param userId - The unique identifier of the user whose GitHub integration is to be disconnected.
 */
export async function disconnectGithub(userId: string): Promise<void> {
  await prisma.connection.deleteMany({
    where: {
      userId,
      type: 'github',
    },
  });

  // Clean up selected repositories
  await prisma.selectedRepository.deleteMany({
    where: {
      userId,
    },
  });

  // Clean up old activities
  await prisma.activity.deleteMany({
    where: {
      userId,
      source: 'github',
    },
  });

  // Clear cache for this user
  await DatabaseCache.clearUserCache(userId);
}

/**
 * Cache warming service for frequently accessed repositories
 */
export class GitHubCacheWarming {
  /**
   * Warm cache for a user's selected repositories
   */
  static async warmUserRepositories(userId: string): Promise<void> {
    try {
      console.log(
        `[GitHub Cache Warming] Starting cache warming for user: ${userId}`
      );

      const connection = await prisma.connection.findFirst({
        where: { userId, type: 'github' },
      });

      if (!connection) {
        console.log(
          `[GitHub Cache Warming] No GitHub connection for user: ${userId}`
        );
        return;
      }

      const selectedRepos = await prisma.selectedRepository.findMany({
        where: { userId },
        orderBy: { updatedAt: 'desc' },
        take: 10, // Warm cache for top 10 most recently updated repositories
      });

      if (selectedRepos.length === 0) {
        console.log(
          `[GitHub Cache Warming] No selected repositories for user: ${userId}`
        );
        return;
      }

      const client = new CachedGitHubClient(connection.accessToken, userId);

      // Warm cache for each repository in parallel
      const warmingPromises = selectedRepos.map(async repo => {
        const [owner, repoName] = repo.repoName.split('/');

        try {
          // Pre-fetch and cache repository data
          await Promise.all([
            client.getCommits(owner, repoName, 10),
            client.getPullRequests(owner, repoName, 10),
            client.getIssues(owner, repoName, 10),
          ]);

          console.log(
            `[GitHub Cache Warming] Warmed cache for ${repo.repoName}`
          );
        } catch (error: any) {
          console.warn(
            `[GitHub Cache Warming] Failed to warm cache for ${repo.repoName}:`,
            error.message
          );
        }
      });

      await Promise.allSettled(warmingPromises);
      console.log(
        `[GitHub Cache Warming] Completed cache warming for ${selectedRepos.length} repositories`
      );
    } catch (error) {
      console.error(
        `[GitHub Cache Warming] Failed to warm cache for user ${userId}:`,
        error
      );
    }
  }

  /**
   * Warm cache for frequently accessed repositories across all users
   */
  static async warmFrequentRepositories(): Promise<void> {
    try {
      console.log(
        '[GitHub Cache Warming] Starting global repository cache warming'
      );

      // Get most frequently selected repositories
      const frequentRepos = await prisma.selectedRepository.groupBy({
        by: ['repoName'],
        _count: { userId: true },
        orderBy: { _count: { userId: 'desc' } },
        take: 20, // Top 20 most selected repositories
      });

      console.log(
        `[GitHub Cache Warming] Found ${frequentRepos.length} frequently accessed repositories`
      );

      // Warm cache for each frequent repository
      for (const repoGroup of frequentRepos) {
        // Get a user who has this repository selected
        const userWithRepo = await prisma.selectedRepository.findFirst({
          where: { repoName: repoGroup.repoName },
          include: {
            user: {
              include: {
                connections: {
                  where: { type: 'github' },
                },
              },
            },
          },
        });

        if (!userWithRepo?.user.connections[0]) {
          continue;
        }

        const [owner, repoName] = repoGroup.repoName.split('/');
        const client = new CachedGitHubClient(
          userWithRepo.user.connections[0].accessToken,
          userWithRepo.userId
        );

        try {
          await Promise.all([
            client.getCommits(owner, repoName, 10),
            client.getPullRequests(owner, repoName, 10),
            client.getIssues(owner, repoName, 10),
          ]);

          console.log(
            `[GitHub Cache Warming] Warmed cache for frequent repository: ${repoGroup.repoName}`
          );
        } catch (error: any) {
          console.warn(
            `[GitHub Cache Warming] Failed to warm cache for ${repoGroup.repoName}:`,
            error.message
          );
        }
      }

      console.log(
        '[GitHub Cache Warming] Completed global repository cache warming'
      );
    } catch (error) {
      console.error(
        '[GitHub Cache Warming] Failed global cache warming:',
        error
      );
    }
  }

  /**
   * Schedule cache warming for a specific repository
   */
  static async scheduleRepositoryWarming(
    userId: string,
    repoName: string
  ): Promise<void> {
    try {
      console.log(
        `[GitHub Cache Warming] Scheduling cache warming for ${repoName}`
      );

      // Use setTimeout to warm cache in the background
      setTimeout(async () => {
        try {
          const connection = await prisma.connection.findFirst({
            where: { userId, type: 'github' },
          });

          if (!connection) return;

          const [owner, repo] = repoName.split('/');
          const client = new CachedGitHubClient(connection.accessToken, userId);

          await Promise.all([
            client.getCommits(owner, repo, 10),
            client.getPullRequests(owner, repo, 10),
            client.getIssues(owner, repo, 10),
          ]);

          console.log(
            `[GitHub Cache Warming] Background warming completed for ${repoName}`
          );
        } catch (error) {
          console.warn(
            `[GitHub Cache Warming] Background warming failed for ${repoName}:`,
            error
          );
        }
      }, 1000); // Delay by 1 second to avoid blocking the main request
    } catch (error) {
      console.error(
        `[GitHub Cache Warming] Failed to schedule warming for ${repoName}:`,
        error
      );
    }
  }
}

/**
 * Cache management functions
 */
export const GitHubCacheManager = {
  /**
   * Get cache statistics
   */
  getStats: () => githubCache.getStats(),

  /**
   * Clear in-memory cache
   */
  clearMemoryCache: () => githubCache.clear(),

  /**
   * Clear database cache
   */
  clearDatabaseCache: () => DatabaseCache.clearExpiredCache(),

  /**
   * Clear all cache for a user
   */
  clearUserCache: (userId: string) => DatabaseCache.clearUserCache(userId),

  /**
   * Clear Redis cache for GitHub data
   */
  clearRedisCache: async (userId?: string) => {
    if (userId) {
      const pattern = `unifiedhq:github:${userId}:*`;
      return await RedisCache.deleteByPattern(pattern);
    } else {
      const pattern = 'unifiedhq:github:*';
      return await RedisCache.deleteByPattern(pattern);
    }
  },

  /**
   * Clear all caches (memory, database, and Redis)
   */
  clearAllCaches: async (userId?: string) => {
    githubCache.clear();

    if (userId) {
      await DatabaseCache.clearUserCache(userId);
      await GitHubCacheManager.clearRedisCache(userId);
    } else {
      await DatabaseCache.clearExpiredCache();
      await GitHubCacheManager.clearRedisCache();
    }
  },

  /**
   * Warm cache for user's repositories
   */
  warmUserCache: (userId: string) =>
    GitHubCacheWarming.warmUserRepositories(userId),

  /**
   * Warm cache for frequently accessed repositories
   */
  warmFrequentCache: () => GitHubCacheWarming.warmFrequentRepositories(),
};
